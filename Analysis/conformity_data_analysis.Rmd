---
title: "conformity_data_analysis"
output: html_document
---

```{r setup, include=FALSE}

knitr::opts_chunk$set(echo = TRUE, error = F, message = F, warning = F)

```

```{r libraries, include=FALSE, message=FALSE, warning=FALSE}

# package for convenience functions (e.g. ggplot2, dplyr, etc.)
library(tidyverse)

# package for this course
#library(aida)

# package for Bayesian regression
library(brms)

library(rstan)

library(bridgesampling)

# parallel execution of Stan code
options(mc.cores = parallel::detectCores())

# use the aida-theme for plotting
# theme_set(theme_aida())
# 
# # global color scheme / non-optimized
# project_colors = c("#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00", "#CC79A7", "#000000")
# 
# # setting theme colors globally
# scale_colour_discrete <- function(...) {
#   scale_colour_manual(..., values = project_colors)
# }
# scale_fill_discrete <- function(...) {
#    scale_fill_manual(..., values = project_colors)
# } 

# nicer global knitr options
knitr::opts_chunk$set(warning = FALSE, message = FALSE, 
                      cache = TRUE, fig.align = 'center')
set.seed(1702)
```


```{r}
raw_data <- read_csv('data_pilot.csv')
raw_data

```
# Demographics

```{r}
raw_data %>% filter(trial_name == 'topic_choice') %>%
  summarize(N = length(submission_id),
            mean_age = mean(age, na.rm = TRUE),
            min_age = min(age, na.rm = TRUE),
            max_age = max(age, na.rm = TRUE),
            sd_age = sd(age, na.rm = TRUE),
            median_ag = median(age, na.rm = TRUE),
            # In der Analyse zur richtigen Studie Großschreiben !!!!
            num_males = sum(gender=="männlich", na.rm = TRUE),
            num_females = sum(gender=="weiblich", na.rm = TRUE),
            num_divers = sum(gender=="divers", na.rm = TRUE),
            num_lower_degree = sum(education == "Real- oder Hauptschulabschluss", na.rm = TRUE),
            num_high_school_degree = sum(education == 'Abitur', na.rm = TRUE),
            num_higher_degree = sum(education == 'Universitärer Abschluss', na.rm = TRUE)
  )
```


# Cleaning data

```{r}
cleaned_data <- raw_data %>% 
  filter(response != 'next', languages != "TEST") %>%
  mutate(trials = paste(trial_name, trial_number, sep = "_")) %>%
  select(-QUD, -RT, - startDate, - startTime, -age, -gender, -education, -languages, -question, -option1, -option2, -trial_name, -trial_number, -experiment_id) %>%
  pivot_wider(
   names_from = trials,
   values_from = response
) %>%
  rename(ingroup_norm = ingroup_info_a, daily_dilemma = dilemma_decision1_4, philosophical_dilemma = dilemma_decision2_4, rating_daily_dilemma = dilemma_decision1_5, rating_philosophical_dilemma = dilemma_decision2_5) %>% 
  mutate(
      passed_understanding_check = case_when(
      understanding_check_1 == "Es ist irrelevant, wie lange du für deine Antworten benötigt hast."& 
      understanding_check_2 == "Anfangs wurden dir mehrere Themen zur Auswahl gestellt." &
      understanding_check_3 == "Wir können dir leider keine Aufwandsentschädigung oder VP Stunden anbieten, sind dir aber sehr dankbar." ~ TRUE)) %>%
  select(-understanding_check_1, -understanding_check_2, -understanding_check_3) %>%
  mutate(
    ingroup_daily = case_when(
      !is.na(daily_dilemma) ~ ingroup_norm
    ),
    ingroup_philo = case_when(
      !is.na(philosophical_dilemma) ~ ingroup_norm
    )) %>%
  group_by(submission_id) %>%
  mutate(
    both_infos = unique(both_infos[!is.na(both_infos)]), 
    topic_choice_1 = unique(topic_choice_1[!is.na(topic_choice_1)]),
    statement_rating_1 = unique(statement_rating_1[!is.na(statement_rating_1)]),
    philosophical_dilemma = unique(philosophical_dilemma[!is.na(philosophical_dilemma)]),
    rating_philosophical_dilemma = unique(rating_philosophical_dilemma[!is.na(rating_philosophical_dilemma)]),
    daily_dilemma = unique(daily_dilemma[!is.na(daily_dilemma)]),
    rating_daily_dilemma = unique(rating_daily_dilemma[!is.na(rating_daily_dilemma)]),
    group_ident_1 = unique(group_ident_1[!is.na(group_ident_1)]),
    group_ident_2 = unique(group_ident_2[!is.na(group_ident_2)]),
    passed_understanding_check = unique(passed_understanding_check[!is.na(passed_understanding_check)]),
    ingroup_daily = unique(ingroup_daily[!is.na(ingroup_daily)]),
    ingroup_philo = unique(ingroup_philo[!is.na(ingroup_philo)])
    ) %>%
  select(-ingroup_norm) %>%
  unique() %>%
  mutate(
    ingroup_norm_daily = case_when(
      ingroup_daily == TRUE ~ -1,
      ingroup_daily == FALSE ~ 1,
    ),
    ingroup_norm_philo = case_when(
      ingroup_philo == TRUE ~ -1,
      ingroup_philo == FALSE ~ 1,
    )) %>%
  mutate_if(is.logical,as.numeric) %>%
  select(-ingroup_daily, -ingroup_philo) %>% 
  pivot_longer(
    cols = c(5, 7),
    names_to = "dilemma_version",
    values_to = "dilemma_rating"
  ) %>% 
  mutate(
    ingroup_norm = case_when(
      dilemma_version == "philosophical_dilemma" ~ ingroup_norm_philo,
      dilemma_version == "daily_dilemma" ~ ingroup_norm_daily
    ),
    ingroup_agree = case_when(
      statement_rating_1 < 0 & group_ident_2 > 0 ~ 1,
      statement_rating_1 > 0 & group_ident_1 > 0 ~ 1,
      statement_rating_1 < 0 & group_ident_2 < 0 ~ 0,
      statement_rating_1 > 0 & group_ident_1 < 0 ~ 0,
    ),
    outgroup_disagree = case_when(
      statement_rating_1 < 0 & group_ident_1 < 0 ~ 1,
      statement_rating_1 > 0 & group_ident_2 < 0 ~ 1,
      statement_rating_1 < 0 & group_ident_1 > 0 ~ 0,
      statement_rating_1 > 0 & group_ident_2 > 0 ~ 0,
    )
  ) %>% 
  select(-ingroup_norm_daily, -ingroup_norm_philo, -rating_philosophical_dilemma, -rating_daily_dilemma) %>%
    transform(dilemma_rating = as.numeric(dilemma_rating)) %>%
  mutate(
      dilemma_version = case_when(
        dilemma_version == "daily_dilemma" ~ 1,
        dilemma_version == "philosophical_dilemma" ~ 2,
      )
    ) %>% 
  mutate(
      dilemma_rating = as.integer(dilemma_rating),
      both_infos = as.integer(both_infos),
      ingroup_norm = as.integer(ingroup_norm),
      ingroup_agree = as.integer(ingroup_agree),
      outgroup_disagree = as.integer(outgroup_disagree),
      statement_rating_1 = as.integer(statement_rating_1),
      topic_choice_1 = as.integer(topic_choice_1),
      group_ident_1 = as.integer(group_ident_1),
      group_ident_2 = as.integer(group_ident_2)
    )
  

cleaned_data

```

```{r}
cleaned_data %>% filter(dilemma_version == 1) %>%
  summarise(
    failed_understanding_check = sum(passed_understanding_check == 0 & !between(statement_rating_1, -2, 2)),
    too_low_statement_rating = sum(between(statement_rating_1, -2, 2) & passed_understanding_check != 0),
    both = sum(passed_understanding_check == 0 & between(statement_rating_1, -2, 2))
  )
```

```{r}
cleaned_data <- cleaned_data %>% 
  filter(!between(statement_rating_1, -2, 2)) %>%
  filter(passed_understanding_check == TRUE)

cleaned_data
```

# Analysis
```{r}
stan_data <- as.list(c(cleaned_data, N = dim(cleaned_data)[1]))
```


```{r}
#Extract priors
write("
data{
    int<lower=1> N;
    int dilemma_rating[N];
    int both_infos[N];
    int ingroup_norm[N];
}
parameters{
    ordered[5] cutpoints;
    real<lower=0> bIn;
    real bBoth;
}
transformed parameters{
    real bOut = -1.4166666667 * bIn;
}
model{
    vector[N] phi;
    cutpoints ~ normal( 0 , 10 );
    bIn ~ normal( 0.816 , 0.5 );
    bBoth ~ normal( 0 , 0.5 );
    for ( i in 1:N ) {
        phi[i] = bIn * ingroup_norm[i] + bBoth * both_infos[i] + bOut * both_infos[i] * ingroup_norm[i];
        dilemma_rating[i] ~ ordered_logistic( phi[i] , cutpoints );
    }
}
generated quantities{
    vector[N] phi;
    real dev;
    vector[N] log_lik;
    dev = 0;
    for ( i in 1:N ) {
        phi[i] = bIn * ingroup_norm[i] + bBoth * both_infos[i] + bOut * both_infos[i] * ingroup_norm[i];
    dev = dev + (-2)*ordered_logistic_lpmf( dilemma_rating[i] | phi[i] , cutpoints );
    log_lik[i] = ordered_logistic_lpmf( dilemma_rating[i] | phi[i] , cutpoints );
    }
}", "alternative_model.stan")

alternative_model <- "alternative_model.stan"
```

```{r}
#stanc(alternative_model)
```


```{r}
stanfit_alt <- stan(file = alternative_model, data = stan_data, iter = 1000, chains = 4,  warmup = 500, seed =123, control=list(adapt_delta = 0.99))
# feed the Stan model back into brms
fit_alt <- brm(dilemma_rating ~ ingroup_norm * both_infos, data = cleaned_data, family = cumulative('logit'), fit = stanfit_alt, save_all_pars = TRUE)
```

```{r}
#Extract priors
write("
data{
    int<lower=1> N;
    int dilemma_rating[N];
    int both_infos[N];
    int ingroup_norm[N];
    int ingroup_agree[N];
    int outgroup_disagree[N];
}
parameters{
    real<lower=0> bIn;
    real bBoth;
    real<lower=0> bOut;
    ordered[5] cutpoints;
}
model{
    vector[N] phi;
    cutpoints ~ normal( 0 , 10 );
    bBoth ~ normal( 0 , 0.5 );
    bOut ~ normal( 0 , 0.5 );
    bIn ~ normal( 0.6/0.75 * 1.02 , 0.5 );
    for ( i in 1:N ) {
        phi[i] = bIn * ingroup_norm[i] * ingroup_agree[i] + bBoth * both_infos[i] + bOut * both_infos[i] * ingroup_norm[i] * outgroup_disagree[i];
        dilemma_rating[i] ~ ordered_logistic( phi[i] , cutpoints );
    }
}
generated quantities{
    vector[N] phi;
    real dev;
    vector[N] log_lik;
    dev = 0;
    for ( i in 1:N ) {
        phi[i] = bIn * ingroup_norm[i] * ingroup_agree[i] + bBoth * both_infos[i] + bOut * both_infos[i] * ingroup_norm[i] * outgroup_disagree[i];
        dev = dev + (-2)*ordered_logistic_lpmf( dilemma_rating[i] | phi[i] , cutpoints );
        log_lik[i] = ordered_logistic_lpmf( dilemma_rating[i] | phi[i] , cutpoints );
    }
}", "sct_model.stan")

sct_model <- "sct_model.stan"
```

```{r}
#stanc(sct_model)
```

```{r}
stanfit_sct <- stan(file = sct_model, data = stan_data, iter = 1000, chains = 4,  warmup = 500, seed =123, control=list(adapt_delta = 0.99))

fit_sct <- brm(dilemma_rating ~ ingroup_norm * ingroup_agree + both_infos + ingroup_norm * both_infos * outgroup_disagree, data = cleaned_data, family = cumulative('logit'), fit = stanfit_sct, save_all_pars = TRUE)
```


```{r}
marg_lik_sct <- brms::bridge_sampler(samples = fit_sct)
marg_lik_alt <- brms::bridge_sampler(samples = fit_alt)
bf(marg_lik_alt,marg_lik_sct)

bf(marg_lik_sct,marg_lik_alt)
```





```{r}
bf(marg_lik_alt, marg_lik_alt)
```

```{r}
bf(marg_lik_sct, marg_lik_sct)
```
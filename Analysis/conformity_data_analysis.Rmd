---
title: "conformity_data_analysis"
output: html_document
---

```{r setup, include=FALSE}

knitr::opts_chunk$set(echo = TRUE, error = F, message = F, warning = F)

```

```{r libraries, include=FALSE, message=FALSE, warning=FALSE}

# package for convenience functions (e.g. ggplot2, dplyr, etc.)
library(tidyverse)

# package for this course
library(aida)

# package for Bayesian regression
library(brms)

# parallel execution of Stan code
options(mc.cores = parallel::detectCores())

# use the aida-theme for plotting
theme_set(theme_aida())

# global color scheme / non-optimized
project_colors = c("#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00", "#CC79A7", "#000000")

# setting theme colors globally
scale_colour_discrete <- function(...) {
  scale_colour_manual(..., values = project_colors)
}
scale_fill_discrete <- function(...) {
   scale_fill_manual(..., values = project_colors)
} 

# nicer global knitr options
knitr::opts_chunk$set(warning = FALSE, message = FALSE, 
                      cache = TRUE, fig.align = 'center')
set.seed(1702)
```


```{r}
raw_data <- read_csv('data_pilot.csv')
raw_data

```

# Cleaning data

```{r}
cleaned_data <- data %>% 
  filter(response != 'next', languages != "TEST") %>%
  mutate(trials = paste(trial_name, trial_number, sep = "_")) %>%
  select(-QUD, -RT, - startDate, - startTime, -age, -gender, -education, -languages, -question, -option1, -option2, -trial_name, -trial_number, -experiment_id) %>%
  pivot_wider(
   names_from = trials,
   values_from = response
)
  

cleaned_data

```
```{r}
cleaned_data <- cleaned_data %>%
  rename(ingroup_norm = ingroup_info_a, daily_dilemma = dilemma_decision1_4, philosophical_dilemma = dilemma_decision2_4, rating_daily_dilemma = dilemma_decision1_5, rating_philosophical_dilemma = dilemma_decision2_5) %>% 
  mutate(passed_understanding_check = case_when(
    understanding_check_1 == "Es ist irrelevant, wie lange du für deine Antworten benötigt hast."& 
    understanding_check_2 == "Anfangs wurden dir mehrere Themen zur Auswahl gestellt." &
    understanding_check_3 == "Wir können dir leider keine Aufwandsentschädigung oder VP Stunden anbieten, sind dir aber sehr dankbar." ~ TRUE)) %>%
  select(-understanding_check_1, -understanding_check_2, -understanding_check_3) %>%
  mutate(
    ingroup_daily = case_when(
      !is.na(daily_dilemma) ~ ingroup_norm
    ),
    ingroup_philo = case_when(
      !is.na(philosophical_dilemma) ~ ingroup_norm
    )) %>%
  group_by(submission_id) %>%
  mutate(both_infos = unique(both_infos[!is.na(both_infos)]), 
         topic_choice_1 = unique(topic_choice_1[!is.na(topic_choice_1)]),
         statement_rating_1 = unique(statement_rating_1[!is.na(statement_rating_1)]),
         philosophical_dilemma = unique(philosophical_dilemma[!is.na(philosophical_dilemma)]),
         rating_philosophical_dilemma = unique(rating_philosophical_dilemma[!is.na(rating_philosophical_dilemma)]),
         daily_dilemma = unique(daily_dilemma[!is.na(daily_dilemma)]),
         rating_daily_dilemma = unique(rating_daily_dilemma[!is.na(rating_daily_dilemma)]),
         group_ident_1 = unique(group_ident_1[!is.na(group_ident_1)]),
         group_ident_2 = unique(group_ident_2[!is.na(group_ident_2)]),
         passed_understanding_check = unique(passed_understanding_check[!is.na(passed_understanding_check)]),
         ingroup_daily = unique(ingroup_daily[!is.na(ingroup_daily)]),
         ingroup_philo = unique(ingroup_philo[!is.na(ingroup_philo)])
         ) %>%
  select(-ingroup_norm) %>%
  unique() %>%
  filter(!between(statement_rating_1, -2, 2)) %>%
  filter(passed_understanding_check == TRUE) %>%
  mutate(
    ingroup_norm_daily = case_when(
      ingroup_daily == TRUE ~ -1,
      ingroup_daily == FALSE ~ 1,
    ),
    ingroup_norm_philo = case_when(
      ingroup_philo == TRUE ~ -1,
      ingroup_philo == FALSE ~ 1,
    )) %>%
  mutate_if(is.logical,as.numeric) %>%
  select(-ingroup_daily, -ingroup_philo, -passed_understanding_check)
cleaned_data
```

```{r}
cleaned_data <- cleaned_data %>% pivot_longer(
  cols = c(5, 7),
  names_to = "dilemma_version",
  values_to = "dilemma_rating"
) %>% mutate(
  ingroup_norm = case_when(
    dilemma_version == "philosophical_dilemma" ~ ingroup_norm_philo,
    dilemma_version == "daily_dilemma" ~ ingroup_norm_daily
  ),
  ingroup_agree = case_when(
    statement_rating_1 < 0 & group_ident_2 > 0 ~ 1,
    statement_rating_1 > 0 & group_ident_1 > 0 ~ 1,
    statement_rating_1 < 0 & group_ident_2 < 0 ~ 0,
    statement_rating_1 > 0 & group_ident_1 < 0 ~ 0,
  ),
  outgroup_disagree = case_when(
    statement_rating_1 < 0 & group_ident_1 < 0 ~ 1,
    statement_rating_1 > 0 & group_ident_2 < 0 ~ 1,
    statement_rating_1 < 0 & group_ident_1 > 0 ~ 0,
    statement_rating_1 > 0 & group_ident_2 > 0 ~ 0,
  )
) %>% select(-ingroup_norm_daily, -ingroup_norm_philo, -rating_philosophical_dilemma, -rating_daily_dilemma) %>% mutate(
  dilemma_rating = factor(dilemma_rating, ordered = TRUE, levels = c(1,2,3,4,5,6))
)

cleaned_data
```


# Analysis

## Implementing the competing models

#### The alternative model
```{r}
alternative_priors <- c(set_prior('normal( 0.816 , 0.5 )', class = "b", coef = 'ingroup_norm'),
  set_prior('normal( 0 , 0.5 )', class = "b", coef = 'both_infos'),
  set_prior('normal( 0.816 , 0.5 )', class = "b", coef = 'ingroup_norm:both_infos'))

alternative_model <- brm(
  family = cumulative('logit'),
  data = cleaned_data,
  formula = dilemma_rating ~ dilemma_version + ingroup_norm * both_infos,
  sample_prior = 'yes', 
  iter = 1000, 
  prior = alternative_priors) 
```

```{r}
summary(alternative_model)
```

#### The self-categorization model
```{r}
self_categorization_priors <- c(set_prior('normal( 0.816 , 0.5 )', class = "b", coef = 'ingroup_norm'),
  set_prior('normal( 0 , 0.5 )', class = "b", coef = 'both_infos'),
  set_prior('normal( 0 , 0.5 )', class = "b", coef = 'ingroup_norm:both_infos'))

self_categorization_model <- brm(
  family = cumulative('logit'),
  data = cleaned_data,
  formula = dilemma_rating ~ dilemma_version + ingroup_norm * ingroup_agree + both_infos + ingroup_norm * both_infos * outgroup_disagree,
  sample_prior = 'yes',
  iter = 1000,
  prior = self_categorization_priors)
```

```{r}
summary(self_categorization_model)
```
## Compring the models via the bayes factor
```{r}

```

